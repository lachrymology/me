<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8"/>
    <meta name="generator" content="Klipbook"/>
    <title>Instapaper - Collated Kindle Clippings</title>
    <style type="text/css">
      body {
        color: #333;
        font-size: 16px;
        line-height: 1.5em;
        font-family: Palatino, Georgia, serif;
        background-color: #fff;
        margin: 0px;
        padding: 20px;
      }
      a {
        text-decoration: none;
      }
      a, a:link, a:visited {
        color: #084ab7;
      }
      a:hover {
        text-decoration: underline;
      }

      h1 {
        line-height: 1.1em;
      }

      h2 {
        line-height: 1.1em;
        font-size: 1.3em;
        color: #555;
        font-style: italic;
      }

      ul {
        margin-top: 2em;
        width: 43em;
      }

      ul li {
        margin: 1.6em 0;
        list-style: none;
      }

      ul li p {
        margin-bottom: .5em;
      }

      ul li footer {
        text-align: right;
        font-size: .85em;
        color: #8C8C8C;
      }

      li.note p {
        font-style: italic;
      }

      footer {
        font-size: .85em;
        margin-left: 20em;
      }

      footer span {
        font-style: italic;
      }
    </style>
  </head>
  <body>

    <h1>Instapaper</h1>
    
      <h2>by Instapaper</h2>
    

    <ul>
      
        
        <li class="highlight">
          <p>
            “Institutions will try to preserve the problem to which they are the solution.”
          </p>
          <footer>
            highlight
            
             @ loc 15
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            The greater the probability a random string is a valid program, the harder it is to report errors well.
          </p>
          <footer>
            highlight
            
             @ loc 19
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            Yet, over in the computer science department, we’re awash in types.  They’re certainly used for reasoning about programs (both practically and theoreticially) — but at some point our reasoning may become more about the types themselves than about the programs they apply to. 
          </p>
          <footer>
            highlight
            
             @ loc 24
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            you cannot achieve 'simplicity' without knowing your problem or requirements very precisely.
          </p>
          <footer>
            highlight
            
             @ loc 24
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            For most people software is a solid edifice - it presents a few modes of interaction to the user,
          </p>
          <footer>
            highlight
            
             @ loc 24
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            In a nutshell, Redline Smalltalk is a version of Smalltalk for the JVM aiming to be as compatible with Pharo Smalltalk as possible.
          </p>
          <footer>
            highlight
            
             @ loc 24
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            with democratic political systems that there is more to be gained by ‘making a point’ then solving the problem.
          </p>
          <footer>
            highlight
            
             @ loc 24
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            You don’t need macros if you know what you are doing (your domain), and your system is already targeted at your domain. Adding macros to ML will have no impact on its usefulness for building theorem provers. You can’t make APL or Matlab better languages for working with arrays by adding macros. But as soon as you need to express new domain concepts in a language that does not natively support them, macros become essential to maintaining good, concise code.
          </p>
          <footer>
            highlight
            
             @ loc 26
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            John Lloyd, Theorem 9.6 in ‘Foundations of Logic Programming’ for a proof that pure Horn clause logic is Turing-equivalent. Qi sequent calculus can represent any pure Horn clause program.
          </p>
          <footer>
            highlight
            
             @ loc 27
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            Bernard Shaw’s play Pygmalion who learns to speak in an upper-class diction in spite of her origins.
          </p>
          <footer>
            highlight
            
             @ loc 29
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            an integral part of the Xerox PARC Philosophy was to dismantle the wall between software developers and computer users, to develop systems so easy to program that doing so would be a natural, simple aspect of computer use.
          </p>
          <footer>
            highlight
            
             @ loc 31
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            In abstract, forking means cloning the entire processes. In practice, though, the operating system has a nifty feature called “copy on write” (CoW). Which says the two processes can share most all of the memory that hasn’t been written to since the fork. As soon as one or the other processes writes to the memory (usually a CPU “page” = 4k), it is copied over into the new processes.
          </p>
          <footer>
            highlight
            
             @ loc 31
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            Qi is still very ‘powerful’ type-theoretically, since Gentzen’s notation has been with us for 60 years and I don’t see a better one. But it is perfectly possible someone will claim they have a more compact notation than sequent calculus.
          </p>
          <footer>
            highlight
            
             @ loc 34
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            Teaching Company’s website for guidance. Here are a few I’ve personally listened to and enjoyed: Famous Greeks Famous Romans Books That Have Made History: Books That Can Change Your Life
          </p>
          <footer>
            highlight
            
             @ loc 34
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            in Ruby it’s not so great. Ruby’s garbage collector (1.9.x) writes to every object every time it runs. This means that the first time either processes triggers garbage collection, the entire processes must be copied. In other words, Ruby loses all benefits of CoW. If you are writing a large application that uses a lot of memory, forking only makes sense for very long-running processes because the overhead of forking is very high.
          </p>
          <footer>
            highlight
            
             @ loc 35
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            be very nice if we could design a system which gave threads the “benefit of the doubt”, assuming that they will not conflict, while still somehow maintaining data integrity.
          </p>
          <footer>
            highlight
            
             @ loc 52
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            we write code in the context of a framework, and the constraints imposed on us help with integration.
          </p>
          <footer>
            highlight
            
             @ loc 56
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            They are basically threads, except they actually share just one OS thread and they only multitask when you tell them to. This makes thread-saftey trivial, much like eventing, PLUS you can still write your code in a linear fashion. A mix of eventing and fibers basically gets you all the simplicity of ignoring thread-safety with little of the conceptual or code overhead of pure eventing.
          </p>
          <footer>
            highlight
            
             @ loc 57
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            The Passenger by Antonioni?
          </p>
          <footer>
            highlight
            
             @ loc 63
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            Our current popular languages are designed to help losers lose less.
          </p>
          <footer>
            highlight
            
             @ loc 67
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            events can usually not be predicted exactly, which tends to make old-style programmers nervous. However, it turns out that this isn’t really necessary (and never has been!), and in fact shifts the emphasis from sequences of actions to transformations performed on streams of data.
          </p>
          <footer>
            highlight
            
             @ loc 78
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            the Doomsday Engine (or jDoom), an open-source engine founded by Jaakko Keränen in 1999. It updates the Doom engine two generations forward, featuring smooth OpenGL performance, colored lighting and softened object glow
          </p>
          <footer>
            highlight
            
             @ loc 86
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            The Prince by Niccolo Machiavelli
          </p>
          <footer>
            highlight
            
             @ loc 87
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            With strict evaluation you can no longer with a straight face tell people: don’t use recursion, reuse the recursion patterns in map, filter, foldr, etc. It simply doesn’t work (in general).
          </p>
          <footer>
            highlight
            
             @ loc 87
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            Clojure seems to take a fair bit of inspiration from Haskell’s STM monad, although it does not port over concepts like transaction composition and what Simon Payton Jones calls “choice”. 
          </p>
          <footer>
            highlight
            
             @ loc 93
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            the CAP Theorem, which states that a distributed system cannot provide consistency, availability, and partition tolerance all at the same time (although two out of three of these properties are achievable at once).
          </p>
          <footer>
            highlight
            
             @ loc 94
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            Marc Lehmann, the author of libev also wrote Perl wrappers for libev and a Coroutine library for Perl, which might explain why the libev API is a good fit for wrapping in a high-level language.
          </p>
          <footer>
            highlight
            
             @ loc 100
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            In short, we’re talking about MVC when a model can notify (through the Observer pattern) the views about the changes. It’s not possible in a classical Rails app (it’s possible when you use WebSockets, Pusher or a similar technology,
          </p>
          <footer>
            highlight
            
             @ loc 102
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            Erlang was designed for building soft real-time fault-tolerant systems that could be upgraded without taking them out of service.
          </p>
          <footer>
            highlight
            
             @ loc 103
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            Disregarding students’ investment as mere rigmarole is equivalent to asserting that Gandhi went on hunger strikes because he wasn’t hungry. Many of us sacrificed for our education and you better damn well pay attention to it.
          </p>
          <footer>
            highlight
            
             @ loc 104
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            Brothers Karamazov by Fyodor Dostoevsky
          </p>
          <footer>
            highlight
            
             @ loc 108
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            Dynamo sees its data as opaque binary blobs, so search is only possible using primary keys. Other NoSQL databases make different choices: MongoDB and CouchDB are document-oriented stores, meaning that data is stored as a JSON-like tree of keys and values; HBase and Cassandra store data as tuples, like a relational database, but without foreign keys.
          </p>
          <footer>
            highlight
            
             @ loc 108
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            That is, our existing words of black box abstraction — the existing words we use for designing our systems — aren’t driving us toward the kinds of solutions we want, they are actually standing in the way of the kinds of solutions we want.
          </p>
          <footer>
            highlight
            
             @ loc 113
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            “object-oriented equational rewrite rules” and IRC bots. &gt; http://lists.canonical.org/pipermail/kragen-tol/2007-March/000855.html
          </p>
          <footer>
            highlight
            
             @ loc 113
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            basic idea of consistent hashing is to decouple the value of a key from the machine it is stored on. If you do this you can add and remove machines from your data store without breaking anything.
          </p>
          <footer>
            highlight
            
             @ loc 119
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            self-quoting keywords, like in Prolog or Erlang (lower-case), or Common Lisp or Ruby (with colons).
          </p>
          <footer>
            highlight
            
             @ loc 122
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            For Whom the Bell Tolls by Ernest Hemingway
          </p>
          <footer>
            highlight
            
             @ loc 123
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            Most explanations of conditions put little or no emphasis on functions having contracts that specify conditions. Few other explanations refer to the propensity of programmers to neglect to check special “error codes”.
          </p>
          <footer>
            highlight
            
             @ loc 125
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            The wheel group is a group which limits the number of people who are able to su to root. This usually consists of a group named “wheel” and a set of users that are permitted to use the utility ‘su’ in order to change to root.
          </p>
          <footer>
            highlight
            
             @ loc 129
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            “Proposing a Unix Portability Experiment,”
          </p>
          <footer>
            highlight
            
             @ loc 137
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            Relational databases may continue to perform a bit better on simple joins, but triple stores already produce better performance when it comes to complicated queries, rule handling and inferencing.
          </p>
          <footer>
            highlight
            
             @ loc 140
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            The Rise of Theodore Roosevelt by Edmund Morris
          </p>
          <footer>
            highlight
            
             @ loc 154
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            In Python, if you want to compose a number of its generators into a coroutine, every procedure in the call stack must cooperate. In fact until recently this wasn’t even possible to implement efficiently.
          </p>
          <footer>
            highlight
            
             @ loc 159
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            For more on delimited continuations, see the readable 1993 paper by Dorai Sitaram, Handling Control.
          </p>
          <footer>
            highlight
            
             @ loc 168
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            Its somewhat funny to consider that a new generation of developers (post C++) consider the features in Ruby to be bleeding edge when in fact they are mostly retro features of things that Smalltalk has done for decades.  The challenge of course is that languages like Python and Ruby have the heat needed to create a strong momentum. 
          </p>
          <footer>
            highlight
            
             @ loc 178
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            Scala does local type inference, which follows from the desire to have separate compilation, and the fact that types serve as (mandatory) documentation at “module boundaries” (i.e., method signatures). You shouldn’t infer them, just like we don’t infer scaladoc.
          </p>
          <footer>
            highlight
            
             @ loc 189
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            A piece of data is an indivisible unit that you hold to be true for no other reason than it exists.
          </p>
          <footer>
            highlight
            
             @ loc 190
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            MenTaLguY’s lazy.rb),
          </p>
          <footer>
            highlight
            
             @ loc 194
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            Dynamo can give you answers that are not definitive but are very useful, with semantics that the application can understand. What about “eventual consistency”?
          </p>
          <footer>
            highlight
            
             @ loc 195
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            there are only two main operations you can do with data: read existing data and add more data. CRUD has become CR.
          </p>
          <footer>
            highlight
            
             @ loc 197
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            In Combining Events And Threads For Scalable Network Services, published in 2007, Peng Li and Stephan Zdancewic describe building a network service that takes a hybrid approach by using threads and events.
          </p>
          <footer>
            highlight
            
             @ loc 203
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            The first is the fact that we had to shadow = in our package. Common Lisp forbids the redefinition of the functions, macros and special forms defined in the standard, so we have to go out of our way if we want to achieve that effect. Barry Margolin provided a rationale for this in comp.lang.lisp post.
          </p>
          <footer>
            highlight
            
             @ loc 203
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            OOP to me means only messaging, local retention and protection and hiding of state-process, and extreme late-binding of all things. It can be done in Smalltalk and in LISP.
          </p>
          <footer>
            highlight
            
             @ loc 204
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            Saul Bellow or a William Faulkner or an Ernest Hemingway.
          </p>
          <footer>
            highlight
            
             @ loc 213
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            starting from next to nothing you get a lot more bang for your buck with functional programming.
          </p>
          <footer>
            highlight
            
             @ loc 219
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            54. Beware of the Turing tar-pit in which everything is possible but nothing of interest is easy.
          </p>
          <footer>
            highlight
            
             @ loc 224
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            A LISP programmer knows the value of everything, but the cost of nothing.
          </p>
          <footer>
            highlight
            
             @ loc 224
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            Fools ignore complexity. Pragmatists suffer it. Some can avoid it. Geniuses remove it.
          </p>
          <footer>
            highlight
            
             @ loc 226
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            In English every word can be verbed. Would that it were so in our programming languages.
          </p>
          <footer>
            highlight
            
             @ loc 227
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            In Haskell for the cloud, a wonderfully clear and well-written paper, Jeff Epstein, Andrew P. Black, and Simon Peyton-Jones describe implementing a distributed system that emulates the message passing functionality of Erlang, with some added Haskell flair.
          </p>
          <footer>
            highlight
            
             @ loc 227
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            Making something variable is easy. Controlling duration of constancy is the trick.
          </p>
          <footer>
            highlight
            
             @ loc 232
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            See Kent Pitman’s Lambda, the Ultimate Political Party for
          </p>
          <footer>
            highlight
            
             @ loc 233
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            Documentation is like term insurance: It satisfies because almost no one who subscribes to it depends on its benefits.
          </p>
          <footer>
            highlight
            
             @ loc 238
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            We should also consider the costs of using hastily designed languages. JavaScript has some crazy bad stuff, like with, var hoisting, a poor numeric model, dynamic this scoping, lack of modularity regarding binding lookup (witness the recent spate of browser bugs regarding prototype lookup on user objects), the strange arguments object, and the lack of tail recursion. Then there are the useful features that JavaScript lacks, like macros, modules, and delimited continuations.
          </p>
          <footer>
            highlight
            
             @ loc 240
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            This is the reason we needed to redirect through retrieve rather than just grabbing the value directly in Ref.  Within a transaction, any dereferencing will polymorphically come to an instance of this class.  The mutable map, world, handles the transaction-local cache of all values once they have been accessed.  Thus, the reference can change after we have looked at it (when another transaction commits) and it doesn’t affect the values local to our transaction.  This technique is exceedingly powerful and in no small part responsible for the higher throughput made possible by the transactional model.
          </p>
          <footer>
            highlight
            
             @ loc 247
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            The future of computing will not be the same as the present. So how will JavaScript adapt to these changes? We can’t tell right now, but given the difficulty in changing simple things like making 010 parse as 10 and not 8 indicates that at some point it will stagnate. But Scheme will still be with us, because its parts are well thought-out,
          </p>
          <footer>
            highlight
            
             @ loc 248
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            Both in VisualWorks and Squeak, when a Block is invoked with a wrong number of arguments, message processing ends with a primitive failure in the valueWithArguments: method. The standard Smalltalk response to that is to complain about the wrong number of arguments. All we need is change that response to curry the receiver when appropriate.
          </p>
          <footer>
            highlight
            
             @ loc 251
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            transactions are always designed to be single-threaded from start to finish.  They are used in multi-threaded situations, they do not use multiple threads.
          </p>
          <footer>
            highlight
            
             @ loc 254
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            “What I’ve written is Proustian in its cumulative effect, and if we eliminate detail we destroy that effect.”
          </p>
          <footer>
            highlight
            
             @ loc 257
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            “Composing Contracts” paper by Simon Peyton-Jones
          </p>
          <footer>
            highlight
            
             @ loc 260
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            Implementations of the next Lisp should not be influenced by previous implementations to make this operation fast, especially at the expense of poor performance of all other function calls.
          </p>
          <footer>
            highlight
            
             @ loc 272
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            A. E. Hotchner is the author of “Papa Hemingway” and “Hemingway and His World.”
          </p>
          <footer>
            highlight
            
             @ loc 274
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            we have to let clients control mapping decisions.
          </p>
          <footer>
            highlight
            
             @ loc 275
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            “My psychoanalytical friends are always telling me that we once needed classical therapy to free us from internalised repression so we could do it. But today you feel guilty if you do not have wide-ranging sexual desire and experience.
          </p>
          <footer>
            highlight
            
             @ loc 283
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            Once enjoyment becomes permitted it slides imperceptibly toward the obligatory.
          </p>
          <footer>
            highlight
            
             @ loc 284
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            Suspicious of simplicity,
          </p>
          <footer>
            highlight
            
             @ loc 295
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            Insisting that objects communicate exclusively via message sends rules out aberrations such as static methods, non-virtual methods, constructors and public fields.
          </p>
          <footer>
            highlight
            
             @ loc 307
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            Aaron W. Hsu - A Philosophy on Scheme Modules
          </p>
          <footer>
            highlight
            
             @ loc 307
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            Ruby 1.9 added Fibers - a construct which can also be used as symmetric coroutine.
          </p>
          <footer>
            highlight
            
             @ loc 312
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            We can nevertheless ask: is Smalltalk a message based programming language? I think not. I would take message-based programming to have an even stronger requirement: all computation is done via message passing. That includes the computation done within a single object as well. Whereas Smalltalk objects can access variables and assign them, message based programming would require that an object use messages internally as well. This is exactly what happens in Self,
          </p>
          <footer>
            highlight
            
             @ loc 316
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            I like the term Message-based Programming (MBP). It implies a lot of valuable design decisions I strongly believe in, while leaving many design alternatives open. The term is, I hope, free of the baggage that is associated with object oriented programming, which has too many flawed interpretations.
          </p>
          <footer>
            highlight
            
             @ loc 321
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            GOLOG family of programming languages,
          </p>
          <footer>
            highlight
            
             @ loc 325
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            I have discovered that there are two types of command interfaces in the world of computing: good interfaces and user interfaces.
          </p>
          <footer>
            highlight
            
             @ loc 325
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            The first thing critical reading courses teach is that analyzing a piece of text involves analyzing its author’s intent.
          </p>
          <footer>
            highlight
            
             @ loc 326
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            The essence of user interfaces is parsing: converting an unstructured sequence of commands, in a format usually determined more by psychology than by solid engineering, into structured data.
          </p>
          <footer>
            highlight
            
             @ loc 326
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            I still use Perl for command-line scripting. Smalltalk doesn’t lend itself to small programs very well.
          </p>
          <footer>
            highlight
            
             @ loc 332
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            switched to an email program that is now over twenty years old: nmh.
          </p>
          <footer>
            highlight
            
             @ loc 333
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            A fexpr is a procedure that acts on the syntax of its operands, rather than on the values determined by that syntax.
          </p>
          <footer>
            highlight
            
             @ loc 335
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            Kiselyov has provided the world a purely-functional object system for you functional-programming junkies.
          </p>
          <footer>
            highlight
            
             @ loc 347
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            So “partition-tolerant” (“P”) means that any guarantee of consistency or availability is still guaranteed even if there is a partition. In other words, if a system is not partition-tolerant, that means that if the network can lose messages or any nodes can fail, then any guarantee of atomicity or consistency is voided.
          </p>
          <footer>
            highlight
            
             @ loc 354
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            transformations should indeed be the central concept, and that the pointful notation, while easy to use, distracts us
          </p>
          <footer>
            highlight
            
             @ loc 359
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            to A Nanopass Framework for Compiler Education [PDF] by Sarkar, Waddell, and Dybvig.
          </p>
          <footer>
            highlight
            
             @ loc 363
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            Message queuing systems work well because (in no particular order): they don’t pretend to be programming language procedure or method calls, so they avoid the associated impedance mismatch problems they don’t try to hide distributed systems issues coupling is low — drop a message into a queue here, pick up a message from a queue there queues can be persistent, or more generally, delivery guarantees can be varied as needed asynchrony payloads need not conform to some made-up IDL type system getting two different messaging systems to interoperate is easier than getting two different RPC or distributed object systems to interoperate
          </p>
          <footer>
            highlight
            
             @ loc 364
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            A list to be evaluated is a combination; its first element is the operator, and the rest of its elements are operands.  The action designated by the operator is a combiner.  A combiner that acts directly on its operands is an operative.  (Legacy terms: an operative that is a data value is a fexpr, an operative that is not a data value is a special form.)  A combiner that isn’t operative is applicative; in that case, the operands are all evaluated, the results of these evaluations are called arguments, and the action is performed on the arguments instead of on the operands.
          </p>
          <footer>
            highlight
            
             @ loc 367
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            some of the work in Smalltalk and then some of the work in SELF which basically says look, I can do very very late code generation.
          </p>
          <footer>
            highlight
            
             @ loc 376
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            a structured combinator style wich makes equational reasoning natural.
          </p>
          <footer>
            highlight
            
             @ loc 376
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            In most mainstream languages, the data types found in the syntax tree are quite different from the data types you operate on at runtime.
          </p>
          <footer>
            highlight
            
             @ loc 379
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            Newton said, “If others would think as hard as I did, then they would get similar results.”
          </p>
          <footer>
            highlight
            
             @ loc 386
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            scripting language for UNIX, aiming to blend the ease of use of the UNIX shell with the power and flexibility of a system programming language like C. Perl quickly became the language of choice for UNIX system administrators.
          </p>
          <footer>
            highlight
            
             @ loc 399
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            For instance, integers and fixed point numbers were exact numeric values, and would not allow rounding or truncation. Implicit conversions between types (say, between int and float) was also not allowed, and explicit conversion operations were predefined only for types for which no unreasonable loss of information would occur.
          </p>
          <footer>
            highlight
            
             @ loc 402
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            evaluation must be carried out only once for each thunk, and subsequent accesses must reuse the calculated value
          </p>
          <footer>
            highlight
            
             @ loc 404
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            One success brought him confidence and courage. One of the characteristics of successful scientists is having courage.
          </p>
          <footer>
            highlight
            
             @ loc 405
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            The locals vocabulary compiles lexical variable usage down to stack shuffling, and curry calls (for constructing quotations that close over a variable).
          </p>
          <footer>
            highlight
            
             @ loc 410
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            problem that objects have is that they are too brittle, they carve the world up too sharply.
          </p>
          <footer>
            highlight
            
             @ loc 411
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            Perl’s unparalleled ability to process text, using powerful features like regular expressions.
          </p>
          <footer>
            highlight
            
             @ loc 411
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            Vyssotsky, Victor A. Darwin: A Game of Survival and (Hopefully) Evolution. New Jersey: Bell Telephone Laboratories, 1961.
          </p>
          <footer>
            highlight
            
             @ loc 412
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            CLU’s greatest strength is in its support for three types of abstractions: procedural, control, and data abstractions.
          </p>
          <footer>
            highlight
            
             @ loc 417
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            If clients get a system that has an inappropriate mapping decisions for them, one way or another, they are going to find a way around that problem.
          </p>
          <footer>
            highlight
            
             @ loc 421
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            It’s not possible even to compute the free variables of a term in $vau-calculus in general.1 This makes compilation, automatic refactoring, and cross-referencing impossible in general.
          </p>
          <footer>
            highlight
            
             @ loc 421
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            The fact that this danger did not lead to a catastrophe before is no guarantee that it will not the next time, unless it is completely understood. When playing Russian roulette the fact that the first shot got off safely is little comfort for the next.
          </p>
          <footer>
            highlight
            
             @ loc 431
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            The call to chain do ... end creates a new Chain object with the block passed in to the constructor. Chain is kind of “blank slate”: all methods inherited from Object are undefined so that any messages it receives go through method missing.
          </p>
          <footer>
            highlight
            
             @ loc 431
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            To show concretely why this is a problem, the call (foldr $and #t some-list) will either be a short-circuiting “and” or not, depending on an implementation detail of the foldr function!
          </p>
          <footer>
            highlight
            
             @ loc 432
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            The Scheme 48 Module System
          </p>
          <footer>
            highlight
            
             @ loc 433
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            Method missing has two cases. It either dynamically defines a method returning a new link in the Chain (in the case of nested chaining), or it delegates the method back to the object that constructed the chain in the first place.
          </p>
          <footer>
            highlight
            
             @ loc 434
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            Douglas McIlroy, at the 1969 Extensible Languages Symposium, described opposing philosophies of programming language design as “anarchist” and “fascist”. 
          </p>
          <footer>
            highlight
            
             @ loc 442
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            a story about Mestre Bimba—the originator of modern Capoeira from
          </p>
          <footer>
            highlight
            
             @ loc 447
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            Relying on tests as a design specification is lazy and unprofessional because you are only testing a very small portion of the solution space of your application (and of course, your tests can have bugs).  Tests also fall extremely short of having the expressiveness needed to articulate the subtle shades that a real specification need to cover to be effective.
          </p>
          <footer>
            highlight
            
             @ loc 448
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            In Ruby, it is practical and somewhat useful to add methods dynamically; in Smalltalk, the practice is generally to treat the methods and classes as static.
          </p>
          <footer>
            highlight
            
             @ loc 452
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            Ruby permits adding methods to individual objects; in Smalltalk, all methods reside in classes.
          </p>
          <footer>
            highlight
            
             @ loc 452
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            “A master wastes no energy. Every motion is precious.” A master makes everything look effortless. Nothing is frustrating or difficult for them because they do nothing that isn’t necessary. The master’s actions are pure and elegant.
          </p>
          <footer>
            highlight
            
             @ loc 454
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            How much did a programmer make an hour when FORTRAN was on the ascendant? How much did memory cost then? How about now? Times have changed. Memory is cheap; programmers are expensive!
          </p>
          <footer>
            highlight
            
             @ loc 455
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            the original Smalltalk was in fact the operating system of the computer.
          </p>
          <footer>
            highlight
            
             @ loc 456
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            we as engineers of software have that the other engineers haven’t had. We have abstract descriptions that automatically run.
          </p>
          <footer>
            highlight
            
             @ loc 457
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            libc replacement, Bionic.
          </p>
          <footer>
            highlight
            
             @ loc 459
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            When using a mathematical model careful attention must be given to uncertainties in the model.
          </p>
          <footer>
            highlight
            
             @ loc 459
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            [foo, *bar] = bletch where “=” is the assignment notation (discussed below) and bletch is an array of at least one element. Then foo will be set to the first element, and bar will be set to the rest. This example emulates Joy’s “snoc” operator (cons spelled backward).
          </p>
          <footer>
            highlight
            
             @ loc 464
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            if you are passing around many constructed dictionaries, which in Web development, for example, tends to be done quite a bit.
          </p>
          <footer>
            highlight
            
             @ loc 478
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            They offer you all these nice ideas such as Test-Driven Development and Pair Programming but they never — ever — disclose the risks and the downsides. 
          </p>
          <footer>
            highlight
            
             @ loc 481
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            macros, of which the key component is “syntax”, a kind of decorated representation of source code. If you write simple macros that don’t do anything like variable capture, you basically don’t have to worry about the distinction between syntax and datum, but when you start selectively messing up hygiene, it becomes important.
          </p>
          <footer>
            highlight
            
             @ loc 482
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            Without detailed understanding, confidence can not be attained.
          </p>
          <footer>
            highlight
            
             @ loc 484
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            The interest and emphasis is now on “information” not “data.” It is clear there is more interest in information, which typically includes a mix of text and numeric data, rather than just data.
          </p>
          <footer>
            highlight
            
             @ loc 485
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            And you start to notice patterns. Specifically, you are often “unpacking” a piece of syntax, doing something to it, and then “resyntaxing” it when you are done.
          </p>
          <footer>
            highlight
            
             @ loc 485
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            Mather is the lead author of Octopus: The Ocean’s Intelligent Invertebrate,
          </p>
          <footer>
            highlight
            
             @ loc 488
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            There's an extra clause in the DEFINE-STRUCTURE form that lets you specify the parser function used to parse the files named in the FILES clause. Now *that's* a general module system!
          </p>
          <footer>
            highlight
            
             @ loc 488
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            If you do not work on an important problem, it’s unlikely you’ll do important work.
          </p>
          <footer>
            highlight
            
             @ loc 490
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            scheme48-module-system community.schemewiki.org
          </p>
          <footer>
            highlight
            
             @ loc 491
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            The general attitude difference seems to prevail, that in Ruby it’s more, write what you mean, and leave efficiency to the language (or library) implementation.
          </p>
          <footer>
            highlight
            
             @ loc 493
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            In order to evaluate the operands in any environment at all, you typically use eval — and eval requires an explicit second argument specifying the environment in which to do the evaluation.  And the most immediately available environment that can be specified is the one for which a local binding has been explicitly provided:  the dynamic environment of the call.
          </p>
          <footer>
            highlight
            
             @ loc 497
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            designers of CLU have left out a major part of structuring: nesting. Nesting of procedures within procedures, clusters within clusters, or clusters within procedures is not allowed.
          </p>
          <footer>
            highlight
            
             @ loc 502
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            Ruby offers convenient translations of assignment syntax into message calls. Smalltalk: “foo at: x put: y”. Ruby: “foo[x] = y”. You write what you mean, not how it is implemented.
          </p>
          <footer>
            highlight
            
             @ loc 503
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            Engelbart and Kay both have complained about how computers have been applied towards automating “what we already do”. Both of them see computers instead as “mind amplifiers”, augmenting our intelligence.
          </p>
          <footer>
            highlight
            
             @ loc 506
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
              [1] Hofer et al. Polymorphic embedding of DSLs. GPCE 2008.
          </p>
          <footer>
            highlight
            
             @ loc 508
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            the earliest versions of ML in the mid-seventies used a type-inference scheme that explicitly allowed functions to have polymorphic types. The notion had been around in research literature earlier than that, but ML was the first real programming language to have the feature.
          </p>
          <footer>
            highlight
            
             @ loc 515
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            In the Smalltalk example on the other hand, the selector is “cueMenuRoleNamed:forPage:andLayout:”. The selector embodies the selection of available input data, so the method that implements it only has to deal with that case.
          </p>
          <footer>
            highlight
            
             @ loc 520
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            an interpreter is a tool for constructing a new universe, with its own inescapable “laws of physics” for the language it interprets. (I got this idea from one of K. Eric Drexler and Mark S. Miller’s Agorics open systems papers).
          </p>
          <footer>
            highlight
            
             @ loc 520
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            So, in looking at keywordism as a whole as addressed in the two languages, I see some strength in Smalltalk in that the keywords are part of the selector, and that the use of keywords with message arguments right at the point where you want to trigger the dispatch is syntactically simple and easy. I see as weaknesses in Smalltalk that the order matters, and that it is not so easy to package up the collection of keyword-argument pairs as a message that can be treated as a whole.
          </p>
          <footer>
            highlight
            
             @ loc 525
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            In Ruby (as in the language Self, the pioneer in this regard, and from which the language Self gets its name), you can usually abbreviate message calls on “self” by omitting the mention of “self”. For example, for “self.foo” you can write simply “foo”. But in Smalltalk, you cannot abbreviate “self foo” by writing simply “foo”. This makes a major economy in writing and reading Ruby code.
          </p>
          <footer>
            highlight
            
             @ loc 540
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            The multitasking model that Perl has historically supported is “fork” and “wait.” The granularity is the process. The flavor is UNIX.
          </p>
          <footer>
            highlight
            
             @ loc 542
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            “If I have seen further than others, it is because I’ve stood on the shoulders of giants.” These days we stand on each other’s feet!
          </p>
          <footer>
            highlight
            
             @ loc 545
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            biography, Austin Osman Spare: The Life and Legend of London’s Lost Artist,
          </p>
          <footer>
            highlight
            
             @ loc 547
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            Smalltalk’s treatment of blocks is plenty economical, whether they are being passed as arguments right at the point of construction or not. I
          </p>
          <footer>
            highlight
            
             @ loc 554
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            guess I can see why this exceptionalism arose; it avoids having the closing parenthesis of the argument list coming right after the end of a block, which I can see would look ugly. But, so much twisting and turning and squirming for a tiny increment of beauty.
          </p>
          <footer>
            highlight
            
             @ loc 555
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            Smalltalk’s syntax includes no control constructs except the “^” (early return). Any kind of “if”, “while”, etc., are made by message calls using blocks. At least, syntactically they appear that way. As the Self designers point out, in reality you can’t override ifTrue:ifFalse: unless the Smalltalk compiler resorts to the sophistication characteristic of the Self compiler. If you could, many programs would run too slowly because they are laced with much conditional code.
          </p>
          <footer>
            highlight
            
             @ loc 565
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            in Smalltalk, if you don’t explicitly write “^” with an expression (which means, return the value of the expression as the result of the call), a Smalltalk method returns “self”
          </p>
          <footer>
            highlight
            
             @ loc 575
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            Google have recently introduced (internally) a DSL called Sawzall that is designed to be used with MapReduce for data analysis.
          </p>
          <footer>
            highlight
            
             @ loc 586
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            Smalltalk requires declaration of all local variables and instance variables. In Ruby, you introduce both simply by usage;
          </p>
          <footer>
            highlight
            
             @ loc 592
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            Lisp macros and C macros do similar things: they allow the programmer to substitute one fragment of code with another before the program gets run. The big difference between the two is that while C macros work by scanning for and replacing literal text phrases within source code, Lisp macros replace portions of a parse-tree instead.
          </p>
          <footer>
            highlight
            
             @ loc 593
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            Ruby absolutely makes the wrong choice by denying the programmers any way, just in the syntax in a block of code as you could observe without looking outside the block,
          </p>
          <footer>
            highlight
            
             @ loc 594
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            A source code element modifies the language in which it occurs.  Starting, say, with standard Java, one introduces a new class, and ends up with a different programming language — almost exactly like standard Java, but not quite because it now has this additional class in it.  That is abstraction, building a new language on top of an old one.
          </p>
          <footer>
            highlight
            
             @ loc 599
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            and since it’s persistent, you still have a nice warm cache even when you are recovering from a system
          </p>
          <footer>
            highlight
            
             @ loc 602
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            Scheme, you could even write a macro that popped up a GUI with a dialog box that asked the user how to compile a particular expression! — and more, all with no extra effort. C++ templates can’t use normal run-time C++ code in the process of expanding,
          </p>
          <footer>
            highlight
            
             @ loc 606
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            An abstractively powerful programming language is, by my reckoning, a language from which one can abstract to a wide variety of other languages. 
          </p>
          <footer>
            highlight
            
             @ loc 608
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            blackboard system in Lisp to experiment with the concepts, you can download the open source GBBopen library (the above diagram was taken from the GBBopen documentation).
          </p>
          <footer>
            highlight
            
             @ loc 610
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            doing really first-class work, and knowing it, is as good as wine, women and song put together,” or if it’s a woman she says, “It is as good as wine, men and song put together.” And if you look at the bosses, they tend to come back or ask for reports, trying to participate in those moments of discovery. They’re always in the way.
          </p>
          <footer>
            highlight
            
             @ loc 613
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            The struggle to make something of yourself seems to be worthwhile in itself.
          </p>
          <footer>
            highlight
            
             @ loc 618
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            Lisp has been described as a language with no syntax.  There is a sense in which that’s true:  if by “syntax” one means “syntax for representing programs rather than data”. 
          </p>
          <footer>
            highlight
            
             @ loc 619
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            Ruby practices depend on the file system as the repository for the software; Smalltalkers use the image.
          </p>
          <footer>
            highlight
            
             @ loc 619
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            Smalltalkers look at their code through the class browser. The source code seems to live in the environment along with the values of variables, etc. The practice with Ruby is to organize the code in a file system.
          </p>
          <footer>
            highlight
            
             @ loc 621
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            I believe, by the way, this is how Lisp should be taught to novices:  Teach them S-expression syntax first, set it firmly in their minds that such expressions are data, and only after that begin to teach them about evaluation. 
          </p>
          <footer>
            highlight
            
             @ loc 625
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            The more power Lisp gives the programmer to control how syntax will be interpreted, the more abstractive power accrues. 
          </p>
          <footer>
            highlight
            
             @ loc 635
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            You find this happening again and again; good scientists will fight the system rather than learn to work with the system and take advantage of all the system has to offer.
          </p>
          <footer>
            highlight
            
             @ loc 638
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            templates are really just a C++ version of Lisp macros geared towards generating type declarations rather than extending C++’s syntax
          </p>
          <footer>
            highlight
            
             @ loc 640
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            This goes back to the “basic irrelevance of syntax” remark.  At heart, parametric polymorphism is semantic, ad hoc is syntactic; one might be tempted to call them “semantic polymorphism” and “syntactic polymorphism”, or even “good polymorphism” and “bad polymorphism”. 
          </p>
          <footer>
            highlight
            
             @ loc 646
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            You should dress according to the expectations of the audience spoken to.
          </p>
          <footer>
            highlight
            
             @ loc 651
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            Symbolics documentation, called “Hints for Macro Writers”, from the Lispm’s Concordia
          </p>
          <footer>
            highlight
            
             @ loc 669
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            The project ambjs is an implementation of AMB I wrote in Javascript using a trampoline. The source and the tests are explained using docco.
          </p>
          <footer>
            highlight
            
             @ loc 672
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            A final distinctive feature in CLU is multiple assignment, where more than one variable can appear on the left hand side of an assignment operator. For instance, writing x,y = y,x would exchange values of x and y. In the same way, functions could return several values, like x,y,z = f(t).
          </p>
          <footer>
            highlight
            
             @ loc 675
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            Doug McIlroy summarized the Unix philosophy as follows. This is the Unix philosophy: Write programs that do one thing and do it well. Write programs to work together. Write programs to handle text streams, because that is a universal interface.
          </p>
          <footer>
            highlight
            
             @ loc 681
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            In practice, programs gain overlapping features over time.  A set of programs may start out orthogonal but lose their uniqueness as they evolve.
          </p>
          <footer>
            highlight
            
             @ loc 684
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            The hard part isn’t writing little programs that do one thing well. The hard part is combining little programs to solve bigger problems. 
          </p>
          <footer>
            highlight
            
             @ loc 686
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            Piping the output of a simple shell command to another shell command is easy. But as tasks become more complex, more and more work goes into preparing the output of one program to be the input of the next program.
          </p>
          <footer>
            highlight
            
             @ loc 688
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
             In the Algol family, the symbol   table is a compiler construction.  In the Lisp family, the symbol table   is a run-time resource.  In this sense, Scheme is a member of the Algol   family and not a member of the Lisp family.
          </p>
          <footer>
            highlight
            
             @ loc 718
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            Chomsky has a philosophy based on the idea that we should focus on the deep whys and that mere explanations of reality don’t matter.
          </p>
          <footer>
            highlight
            
             @ loc 719
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            cluster that implements complex numbers:     complex_number = cluster is add, subtract, multiply, ....          rep = record [ real_part: real, imag_part: real ]          add = proc ... end add;          subtract = proc ... end subtract;          multiply = proc ... end multiply;          ...     end complex_number;
          </p>
          <footer>
            highlight
            
             @ loc 726
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            AMD’s upcoming “Cray on a Chip”.
          </p>
          <footer>
            highlight
            
             @ loc 736
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            Tutorial: Metacompilers Part 1, about META II, the one Alan Kay and the other VPRI folks always talk about.
          </p>
          <footer>
            highlight
            
             @ loc 745
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            Evans and Sutherland explaining computer hardware; Fano and Corbato on operating systems; Tony Oettinger describing his natural language parser; and the two giants of my own subfield (Artificial Intelligence), McCarthy and Minsky, on Information Theory and AI.
          </p>
          <footer>
            highlight
            
             @ loc 793
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            issue:  Christopher Strachey‘s contribution on “System Analysis and Programming.”
          </p>
          <footer>
            highlight
            
             @ loc 796
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            A lot of what people call early 1950s “macros” appear to be unconstrained text rewriting rather than expansion of an identifier. Lisp probably pioneered “semantic” macros (as opposed to text macros), but they did not exist in the early 1960s Lisp 1.5
          </p>
          <footer>
            highlight
            
             @ loc 812
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            each extra month with Haskell gave me an extra month of new perspective on what it means to compute from type classes to laziness to combinators to, yes, monads.
          </p>
          <footer>
            highlight
            
             @ loc 821
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            (defun @eval (exp env cont)   (cond ((numberp exp) (funcall cont exp))         ((stringp exp) (funcall cont exp))         ((symbolp exp) (@lookup exp env cont))         ((eq (first exp) 'LAMBDA)          (funcall cont (list 'CLOSURE (second exp) (rest (rest exp)) env)))         ((eq (first exp) 'IF)          (@eval (second exp) env                 #'(lambda (test)                     (@eval (cond (test (second exp)) (t (third exp))) env cont))))         ((eq (first exp) 'LETREC)          (@evletrec (second exp)                     (third exp)                     (pairlis (mapcar #'first (second exp))                              (make-list (length (second exp)))                              env)                     cont))         (t (@eval (first exp) env                   #'(lambda (fn)                       (@evlis (rest exp) env                               #'(lambda (args) (@apply fn args cont)))))))) (defun @lookup (name env cont)   (cond ((null env) (funcall cont name))         ((eq (car (first env)) name) (funcall cont (cdr (first env))))         (t (@lookup name (rest env) cont)))) (defun @evlis (exps env cont)   (cond ((null exps) (funcall cont '()))         (t (@eval (first exps) env                   #'(lambda (arg)                       (@evlis (rest exps) env                               #'(lambda (args) (funcall cont (cons arg args))))))))) (defun @evletrec (bindings body env cont)   (cond ((null bindings) (@eval body env cont))         (t (@eval (second (first bindings)) env                   #'(lambda (fn)                       (rplacd (assoc (first (first bindings)) env) fn)                       (@evletrec (rest bindings) body env cont)))))) (defun @apply (fn args cont)   (cond ((eq fn '+) (funcall cont (+ (first args) (second args))))         ((eq fn '*) (funcall cont (* (first args) (second args))))         ((eq fn 'print)          (princ (first args))          (fresh-line)          (funcall cont (first args)))         ((eq fn 'call/cc)          (@apply (first args) (list (list 'CONTINUATION cont)) cont))         ((atom fn) (funcall cont 'UNDEFINED-FUNCTION))         ((eq (first fn) 'CLOSURE)          (@evlis (third fn) (pairlis (second fn) args (fourth fn))                  #'(lambda (vals) (funcall cont (first (last vals))))))         ((eq (first fn) 'CONTINUATION)          (funcall (second fn) (first args)))         (t (funcall cont 'UNDEFINED-FUNCTION)))) (defun test ()   (@eval '((call/cc             (lambda (goto)               (letrec ((start                         (lambda ()                           (print &quot;start&quot;)                           (goto next)))                        (froz                         (lambda ()                           (print &quot;froz&quot;)                           (goto last)))                        (next                         (lambda ()                           (print &quot;next&quot;)                           (goto froz)))                        (last                         (lambda ()                           (print &quot;last&quot;)                           (+ 3 4))))                       start))))          '()          (lambda (x) x))) Here is the output from running “test”: CL-USER&gt; (test) start next froz
          </p>
          <footer>
            highlight
            
             @ loc 825
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            work done on Classboxes in Smalltalk-80 and Java is a very interesting application of similar ideas to modularisation
          </p>
          <footer>
            highlight
            
             @ loc 836
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            economic libertarianism is based on the same reductionist view of human beings as rational economic actors as 19th century classical economics — a drastic over-simplification of human behaviour. Like Communism, Libertarianism is a superficially comprehensive theory of human behaviour that is based on flawed axioms and, if acted upon, would result in either failure or a hellishly unpleasant state of post-industrial feudalism.)
          </p>
          <footer>
            highlight
            
             @ loc 844
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            checkers involves positions, moves and the values associated with them. Strachey the programmer then implements a nice representation of a board position as a  four-tuple of elements: the player whose turn it is, the locations of that player’s pieces, the locations of the opponent’s pieces and the locations of the kings.
          </p>
          <footer>
            highlight
            
             @ loc 844
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            The new version of the data structure and the old version exist simultaneously, for as long as there are outstanding references to them.
          </p>
          <footer>
            highlight
            
             @ loc 851
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
             There are two fundamental problems with type classes.  The first is that they insist that a type can implement a type class in exactly one way.
          </p>
          <footer>
            highlight
            
             @ loc 879
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            Dialects: Lisp 1.5, Lisp 2, Logo, MacLisp, Standard Lisp, Lisp Machine Lisp, InterLisp, 3-Lisp, LeLisp, EuLisp, ISLisp, Dylan, Prolog, Smalltalk, APL Scheme, T, Common Lisp
          </p>
          <footer>
            highlight
            
             @ loc 879
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
             In F# the problem is even less excusable, in my opinion, for they started with the right thing (Caml) and eliminated the very thing that matters the most about ML, it’s module system!
          </p>
          <footer>
            highlight
            
             @ loc 884
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            Books: The Art of the Meta-Object Protocol, Programming the Lisp Machine, 3-Lisp, Chaitin, Chinual
          </p>
          <footer>
            highlight
            
             @ loc 884
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            We should return a new function from f, every time it is called. But, C doesn’t let you define new functions at run-time. Clearly, function pointers alone are not sufficient. What we need are closures.
          </p>
          <footer>
            highlight
            
             @ loc 886
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            We should be doing more of this. A lot more of this. I’m talking about fork(2), execve(2), pipe(2), socketpair(2), select(2), kill(2), sigaction(2), and so on and so forth. These are our friends. They want so badly just to help us.
          </p>
          <footer>
            highlight
            
             @ loc 891
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            only the Perl people seem to regularly (and happily) apply common Unix idioms to a wide range of problem areas.
          </p>
          <footer>
            highlight
            
             @ loc 902
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            Documentation is likely part of the problem. Here’s a small sample of Ruby core docs on an assortment of Unix system calls — the kind we don’t use enough: Process::fork – oh, sorry, see Kernel::fork … pitiful. Kernel::exec – really? Process::kill – thanks! IO::pipe – not bad. Socket::socketpair – entirely
          </p>
          <footer>
            highlight
            
             @ loc 905
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            The sad truth is we value selling products over our children’s future well being and education. We value buying stuff right now over investing in a better future. We value gluttony over governance.
          </p>
          <footer>
            highlight
            
             @ loc 906
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            This whole Groupon thing has gotten out of control. We are falling farther behind the world in education, yet we seem to excel in creating new ways to spend money quicker and eat cupcakes faster.
          </p>
          <footer>
            highlight
            
             @ loc 909
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            methodology, the “design patterns”, the “style guidelines”, all get in the way of teaching the principles.
          </p>
          <footer>
            highlight
            
             @ loc 914
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            Alan Bawden’s excellent paper “Quasiquotation in Lisp”
          </p>
          <footer>
            highlight
            
             @ loc 922
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
             Dijkstra used to say “beauty is our business”, to which I would add that life is too short, and bright minds too precious, to waste on ugly things.
          </p>
          <footer>
            highlight
            
             @ loc 924
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            Jean-Claude Izzo’s Total Chaos, the first of his Marseilles Trilogy,
          </p>
          <footer>
            highlight
            
             @ loc 925
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            Performance and Evaluation of Lisp Systems - Describes a methodology for improving Lisp performance.
          </p>
          <footer>
            highlight
            
             @ loc 928
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            Advanced Lisp Technology - Focus on recent research on Lisp in Japan.
          </p>
          <footer>
            highlight
            
             @ loc 932
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            Scheme 48’s Lispy implementation language (LIL - an adjective coined at MIT in the 1970’s) was later dubbed ‘Pre-Scheme’.
          </p>
          <footer>
            highlight
            
             @ loc 944
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            Manfred von Thun: Whereas all other [note: should be ‘most other’] functional programming languages are based on the application of functions to arguments, Joy is based on the composition of functions. All such functions take a stack as argument and produce a stack as value.
          </p>
          <footer>
            highlight
            
             @ loc 947
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            Your development experience is no longer code, compile, test, debug, iterate. Instead, the process becomes more holistic - coding, testing, debugging are all the same thing. Very Zen-like,eh? ;-)
          </p>
          <footer>
            highlight
            
             @ loc 960
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            general IPC-based balanced multiprocessing.
          </p>
          <footer>
            highlight
            
             @ loc 964
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
             When a generator suspends, it's exactly like a return today except we simply decline to decref the frame.  That's it!  The locals, and where we are in the computation, aren't thrown away.  A &quot;resume&quot; then consists of *re*starting the frame at its next bytecode instruction,
          </p>
          <footer>
            highlight
            
             @ loc 970
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            (define (a) 1) (define (alpha) (a)) (alpha)             ;  1 (define (a) -1) (alpha)             ; -1 (define-syntax b (syntax-rules () ((_) 2))) (define (beta) (b)) (beta)              ;  2 (define-syntax b (syntax-rules () ((_) -2))) (beta)              ;  2 still! The function being applied, a, in the first half of the code above, is dynamically determined when the application occurs. A redefinition of a means that calling alpha will reflect that change. Dynamic languages. Late binding. Yay! In the second half of the code above, the special form, b, is determined and expanded when beta is first defined and redefining b has no affect on later calls to beta.
          </p>
          <footer>
            highlight
            
             @ loc 971
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            Effective, secure, and scalable support for composing heterogeneous data models has been a desiderata on my language design efforts for many years, and heavily influenced the development of reactive demand programming. I won’t claim a panacea, but RDP will significantly ease the burden on developers when composing heterogeneous data models.
          </p>
          <footer>
            highlight
            
             @ loc 971
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            T’s object system, specifically the use of objects instead of strings as method selectors, had an influence on Joule.
          </p>
          <footer>
            highlight
            
             @ loc 972
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            Coroutines grew up in simulation languages because they're an achingly natural way to model independent objects that interact with feedback.
          </p>
          <footer>
            highlight
            
             @ loc 984
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            A concurrent program is one with multiple threads of control.  Each thread of control has effects on the world, and those threads are interleaved in some arbitrary way by the scheduler.  We say that a concurrent programming language is non-deterministic, because the total effect of the program may depend on the particular interleaving at runtime. 
          </p>
          <footer>
            highlight
            
             @ loc 984
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            VLisp (1995) was a verified Lisp developed by Mitch Wand, John Ramsdell, et al.
          </p>
          <footer>
            highlight
            
             @ loc 986
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            Reconstructed Usenet archives, including the Wiseman collection.
          </p>
          <footer>
            highlight
            
             @ loc 989
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            A source code element modifies the language in which it occurs.  Starting, say, with standard Java, one introduces a new class, and ends up with a different programming language — almost exactly like standard Java, but not quite because it now has this additional class in it.  That is abstraction, building a new language on top of an old one. Abstraction:  Transformation of one programming language into another by means of facilities available in the former language.
          </p>
          <footer>
            highlight
            
             @ loc 989
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            David Moon’s talk about how to do macros for a language with syntax was very innovative,
          </p>
          <footer>
            highlight
            
             @ loc 990
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            person describing the 1802 as having 32 bytes of RAM and 65535 I/O ports.
          </p>
          <footer>
            highlight
            
             @ loc 994
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            An abstractively powerful programming language is, by my reckoning, a language from which one can abstract to a wide variety of other languages. 
          </p>
          <footer>
            highlight
            
             @ loc 998
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            The idea that semantic results are languages is a very powerful one.  The results of computations (and any other embellishment one wants) can be modeled by introducing additional sorts of terms that may occur in languages; the significance of each language is then fully represented by the possible sequences of terms that can follow from it.  But then, one doesn’t really need the explicit semantics at all.  Only the sequences of terms matter, and one can define a programming language by a set of sequences of terms.  At that point, one could say that all semantics is being represented as syntax (which is a truism about semantics, anyway), or one could just as well say that semantics has vanished entirely to be replaced with pure syntax.
          </p>
          <footer>
            highlight
            
             @ loc 1004
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            The rule for interpreting nested backquotes is that a comma is paired with the innermost backquote surrounding (and “raises” its argument out of that context, so that the next comma matches up with the next backquote, and so forth).
          </p>
          <footer>
            highlight
            
             @ loc 1008
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            Lisp has been described as a language with no syntax.  There is a sense in which that’s true:  if by “syntax” one means “syntax for representing programs rather than data”. 
          </p>
          <footer>
            highlight
            
             @ loc 1009
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            Concurrency is most useful as a method for structuring a program that needs to communicate with multiple external clients simultaneously, or respond to multiple asynchronous inputs. 
          </p>
          <footer>
            highlight
            
             @ loc 1012
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            There are actual TOPS-10 systems on the net you can get accounts on. They’re not easy to get into.
          </p>
          <footer>
            highlight
            
             @ loc 1014
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            Notice how the order of evaluation is outside-in, while the nested-backquote rule is inside-out. Very, very confusing.
          </p>
          <footer>
            highlight
            
             @ loc 1017
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            Ron Garret’s paper on a module system for Lisp.
          </p>
          <footer>
            highlight
            
             @ loc 1018
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            the semantics of goto turned out to be trivial:  at a branch point, you can go one of two ways.  Represent one of those ways by a function f that computes what happens if you branch one way, and the other way by a function g.  Then an if+goto simply picks one of f or g as &quot;the continuation&quot; of the program, depending on whether the &quot;if&quot; condition is true or false.  And a plain goto simply replaces the current continuation with a different one (representing what happens at the branch target) unconditionally.
          </p>
          <footer>
            highlight
            
             @ loc 1019
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            Modern computing environments tend to favor form over function: the primary objective in their design is ease of use for non-experts. Unix is a naked celebration of function over form.
          </p>
          <footer>
            highlight
            
             @ loc 1020
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            Use nested backquotes. Use LIST, APPEND, etc. in the inner level, instead of backquote. Use an auxiliary function which uses backquote. Use an alternative backquote implementation.
          </p>
          <footer>
            highlight
            
             @ loc 1022
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            In Unix, a word is worth a thousand mouse clicks.
          </p>
          <footer>
            highlight
            
             @ loc 1023
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            Chubby: Google’s distributed lock system.
          </p>
          <footer>
            highlight
            
             @ loc 1024
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            What Jason Scott did with textfiles.com is heroic. He’s saving away all this stuff that is completely unique, and irretrievable otherwise.
          </p>
          <footer>
            highlight
            
             @ loc 1026
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            Harland, David M. “Polymorphic Programming Languages”, Ellis Horwood 1984.
          </p>
          <footer>
            highlight
            
             @ loc 1031
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            Grust, Torsten “The construction of a SASL Compiler” Web page, accessed 2005, Department of Mathematics and Computer Science University of Konstanz, Germany view detailsExternal link: Online
          </p>
          <footer>
            highlight
            
             @ loc 1037
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            (OlegKiselyov’s purely functional object-oriented system at http://pobox.com/~oleg/ftp/Scheme/index.html#pure-oo),
          </p>
          <footer>
            highlight
            
             @ loc 1061
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            Here’s another one you didn’t mention.  Look at www.python.org and www.ruby-lang.com.  They immediately tell you what the language is and what’s good about it (and they’re attractive).  Now look at www.lisp.org. 
          </p>
          <footer>
            highlight
            
             @ loc 1069
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
             Emacs is _not_ the &quot;press the TAB key to move the cursor to next tab stop&quot; type of software.
          </p>
          <footer>
            highlight
            
             @ loc 1080
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            For languages that support currying and partial-application easily, there is one compelling series of arguments, originally from Chris Okasaki: Put the data structure as the last argument Why? You can then compose operations on the data nicely. E.g. insert 1 $ insert 2 $ insert 3 $ s. This also helps for functions on state.
          </p>
          <footer>
            highlight
            
             @ loc 1083
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            A summary of the Okasaki view is given in his Edison library (again, another data structure library):
          </p>
          <footer>
            highlight
            
             @ loc 1093
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            He’s all in favour of women, as long as they satisfy his own ideals of what a woman should be. This kind of attitude is typified by the skeptic-oriented webcomic xkcd. “I like nerdy girls”, says Randall Munroe — but can he tolerate any others?
          </p>
          <footer>
            highlight
            
             @ loc 1116
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            Despite a resurgence of functional programming in the past few years, it remains a technology more talked about than used.
          </p>
          <footer>
            highlight
            
             @ loc 1130
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            “Success” is all too often assumed to be the indicator of the value of a man. But success, in and of itself, merely speaks to a particular status and may have nothing to do with the journey that the man took to get there, or whether or not he retained his integrity along the way.
          </p>
          <footer>
            highlight
            
             @ loc 1131
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            There is also a paper published in the book Advances in Object-Oriented Metalevel Architectures and Reflection, edited by Chris Zimmermann, with some more detailed suggestions.
          </p>
          <footer>
            highlight
            
             @ loc 1156
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            the balance between giving the programmer of a CLOS implementation more possibilities to optimize things and the user of the MOP more flexilibity to change them is a delicate issue.
          </p>
          <footer>
            highlight
            
             @ loc 1159
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            Lunacy Lunacy is a virtual-machine/compiler for the ‘diamond-like’ core of the Scheme programming language
          </p>
          <footer>
            highlight
            
             @ loc 1165
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            HScheme a Scheme interpreter written in Haskell.
          </p>
          <footer>
            highlight
            
             @ loc 1166
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            one can regard events as having a purpose, or one can regard events as having a cause; these are very different metaphors, that lead to very different perceptions of reality. The existence of such metaphors is uncontroversial, by the way; this isn’t wishy-washy pomo stuff. Even Dawkins acknowledges them: he calls them memes.
          </p>
          <footer>
            highlight
            
             @ loc 1179
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            and was reminded that Smalltalk doesn’t have built-in conditionals. Instead, they use method calls (aka message sends) to do the heavy lifting:
          </p>
          <footer>
            highlight
            
             @ loc 1194
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            Algebraic datatypes are what you get when you have a system that includes two ways of building up new types: products and sums. A product type is the more familiar of the two. Tuples, records, structs, and objects are all examples of product types. A product type combines multiple values of different types into a single value. These are called product types because they correspond mathematically to Cartesian products of the constituent types. A sum type corresponds to a disjoint union of the constituent types, and it is used to express multiple possibilities. Where product types are used when you have multiple things at the same time (a and b and c), sum types are used when you want to enumerate different possibilities (a or b or c).
          </p>
          <footer>
            highlight
            
             @ loc 1200
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            In Ruby, unlike Smalltalk, message sends use a “.“, so we need to use periods between the message sends to link them together. With that exception, the semantics of the two languages are roughly identical.
          </p>
          <footer>
            highlight
            
             @ loc 1203
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            old scientists, have greater stubbornness. Much more common is the scenario described by Max Planck: “A new scientific truth does not triumph by convincing its opponents and making them see the light, but rather because its opponents eventually die, and a new generation grows up that is familiar with it.”
          </p>
          <footer>
            highlight
            
             @ loc 1216
          </footer>
        </li>
        
      
        
        <li class="note">
          <p>
            programmimg oop fn etc.
          </p>
          <footer>
            note
            
             @ loc 1218
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            I’ve never seen a depth-first collector anywhere but T. By the way, the T garbage collector was written in T. This is also a slightly amazing feat. It was achieved by virtue of the fact that T was native-code compiled, and the garbage collector was written by the compiler authors.
          </p>
          <footer>
            highlight
            
             @ loc 1221
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            Good Scheme compilers use a range of implementations for the lambdas in the program, depending upon what they can determine about the lambdas at compile time — how they’re used, to where they are passed, the relationship between the uses and the definition points, etc. Some lambdas just evaporate into nothing. Some lambdas turn into control-flow join points with associated register/variable bindings. Some lambdas turn into stack frames. But some lambdas cause heap allocation to produce general closures.
          </p>
          <footer>
            highlight
            
             @ loc 1226
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            Rubinius, for instance, has used Squeak Smalltalk as a model for implementing their VM, and GemStone’s Maglev is built right on top of a Smalltalk VM.
          </p>
          <footer>
            highlight
            
             @ loc 1236
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            The &gt;&gt; and &gt;&gt;= functions concatenate IO actions in exactly the same sense that the ++ function concatenates Strings. It’s possible for us to do this because e.g. calling readLn doesn’t immediately read from standard input. It is a referentially transparent expression that returns an IO action.
          </p>
          <footer>
            highlight
            
             @ loc 1241
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            Smalltalk has also managed to avoid the many variants of Lambdas, Procs and Blocks in Ruby,
          </p>
          <footer>
            highlight
            
             @ loc 1244
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            can’t help but be suspicious of a field in which research is dominated by a handful of particularly large and unscrupulous corporations.
          </p>
          <footer>
            highlight
            
             @ loc 1247
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            The AST was a tree of objects, connected together in both directions — parents knew their children; children also had links to their parents.
          </p>
          <footer>
            highlight
            
             @ loc 1247
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            medical science has tended to pathologise those sets of symptoms which interfere with an individual’s participation in the profit system
          </p>
          <footer>
            highlight
            
             @ loc 1250
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            Smalltalk’s IDEs,  on the other hand, are written in Smalltalk.
          </p>
          <footer>
            highlight
            
             @ loc 1255
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            All hot compilers do DFA. It is necessary for all the really cool optimisations, like loop-invariant hoisting, global register allocation, global common subexpression elimination, copy propagation, induction-variable elimination.
          </p>
          <footer>
            highlight
            
             @ loc 1263
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            No. If either of the following statements were true, Asian and Indian kids would be performing poorly in American public schools as well: American public schooling is simply poor altogether, and it’s impossible to do well American public school is biased against non-whites, which is why blacks and hispanics do so poorly But Asian and Indian kids are academically dominating. These students aren’t just outperforming Blacks and Hispanics in the same exact schools, they’re also outperforming White students. Why is that? How are Asians and Indians doing so well in an academic environment that’s supposedly hard to thrive in?
          </p>
          <footer>
            highlight
            
             @ loc 1265
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            I’d love to see the GOF’s appropriation of Alexander critiqued, and maybe brought into contact with the concerns raised in Heidegger’s essay The Question Concerning Technology).
          </p>
          <footer>
            highlight
            
             @ loc 1271
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            InfoQ: Ruby 1.9 added Fibers - a construct which can also be used as symmetric coroutine. Some Smalltalk versions also use these instead of exposing heavyweight kernel threads
          </p>
          <footer>
            highlight
            
             @ loc 1276
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            It was also a massive validation of a thesis Steele had argued for his Master’s, which was that CPS was a great intermediate representation for a compiler. Orbit was totally hard-core about this — the first thing the compiler did was translate the user program into CPS, and that was the standard form on which the compiler operated for the rest of its execution.
          </p>
          <footer>
            highlight
            
             @ loc 1278
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            In Unix, thread is spelled “f o r k” for a reason. I think sharing should be opt-in, rather than opt-out,
          </p>
          <footer>
            highlight
            
             @ loc 1279
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            Filaments [7] and NT’s Fibers are good examples of cooperative user-level threads packages, although neither is targeted at large numbers of blocking threads.
          </p>
          <footer>
            highlight
            
             @ loc 1292
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            Stanford Encyclopedia of Philosophy
          </p>
          <footer>
            highlight
            
             @ loc 1295
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            I still use Perl for command-line scripting. Smalltalk doesn’t lend itself to small programs very well.
          </p>
          <footer>
            highlight
            
             @ loc 1296
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            (Monkey Patching)? Have you used Squeak’s Traits?
          </p>
          <footer>
            highlight
            
             @ loc 1298
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            The example uses algebraic datatypes to encode invariants, but OCaml has other tools for doing the same. OCaml’s module system is one example, allowing you to specify invariants in the interface of a module.
          </p>
          <footer>
            highlight
            
             @ loc 1301
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            So the lineage of the CPS-as-compiler-IR thesis goes from Steele’s Rabbit compiler through T’s Orbit to SML/NJ.
          </p>
          <footer>
            highlight
            
             @ loc 1304
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            Whatever the form of the aforementioned type information, you depend on it to compile your code - you cannot compile without it. In some languages, this introduces ordering dependencies among compilation units.
          </p>
          <footer>
            highlight
            
             @ loc 1304
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            In Smalltalk, a class combines data layout, supertype relations, and behavior into a single construct. CLOS increases the programmer’s flexibility by separating data layout and supertype relations from behavior. CLOS classes define the representation of data and the relations among types, and generic functions define behavior. Bard takes this factoring a step further, separating data layout from type relationships.
          </p>
          <footer>
            highlight
            
             @ loc 1306
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            Kevin Lang (who built a little known but quite beautiful, elegant, free and portable object-oriented Scheme called Oaklisp),
          </p>
          <footer>
            highlight
            
             @ loc 1313
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            If you rely on inference at module boundaries, your module leaks implementation information. Why? Because if you infer types from your implementation, those types may vary when you modify your implementation. That is why, even in ML, signatures are declared explicitly.
          </p>
          <footer>
            highlight
            
             @ loc 1315
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            inference only works well within a module (if that).
          </p>
          <footer>
            highlight
            
             @ loc 1315
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            Not image-based. Which means it uses files which means anybody can use their favourite editor to type up hello world and get going.
          </p>
          <footer>
            highlight
            
             @ loc 1317
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            Skeptics ask society’s castaways to leave a reality in which they are good and valued people, and enter one in which they are pieces of warm garbage. Little wonder that so few take up the offer.
          </p>
          <footer>
            highlight
            
             @ loc 1318
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            First because dealing with an image means you’re dealing with live objects, right here and now, and not an indirection. Second because dealing directly with objects which are all precompiled unshackles you from the edit-compile cycle. Third because tools built specifically to deal with code (eg, the RefactoringBrowser) are vastly superior to “your favourite editor” or “normal tools”. Fourth because version control is much more sophisticated in image-based systems, like all code-handling
          </p>
          <footer>
            highlight
            
             @ loc 1321
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            But mapping out the philosophical landscape of computer science is no easy task. Fortunately, traditional branches of philosophy can provide intellectual and structural guidance.
          </p>
          <footer>
            highlight
            
             @ loc 1323
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            One of the things Alexander Bird’s book Philosophy of Science taught me was how to identify unproductive skepticism, even when it is not obvious, in things such as Hume’s problem of induction.
          </p>
          <footer>
            highlight
            
             @ loc 1323
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            version control: Envy uses a per method version control database that keeps track of all your changes at a per method basis. It also allows you to close a class from further changes and thus “releasing” it to the rest of your team. Integration developers can then pick and chose from the class database to select what version of the app to use. The UI is very slick and programmable. By comparison, filebased tools like subversion require you to do odd things like “branch” to work on concurrent versions of things and have a real file-based mentality to them. Envy knows about classes, methods, and “applications” and can help you build an app from several parts quite powerfully and easily.
          </p>
          <footer>
            highlight
            
             @ loc 1336
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            (Implementing the runtime for a functional language, in some sense, requires you to implement a little virtual OS on top of the real, underlying OS.)
          </p>
          <footer>
            highlight
            
             @ loc 1341
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            Representing Type Information in Dynamically Typed Languages ftp://ftp.cs.indiana.edu/pub/scheme-repository/doc/pubs/typeinfo.ps.gz How to keep track of what things are of what type. Useful in implementing list structured
          </p>
          <footer>
            highlight
            
             @ loc 1350
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            Arithmetic precedence is incompatible with ST because ST precedence is based entirely on associative (partial) ordering.
          </p>
          <footer>
            highlight
            
             @ loc 1353
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            Definitional Interpreters for Higher-Order Programming Languages http://www.brics.dk/~hosc/local/HOSC-11-4-pp363-397.pdf This paper has a fairly thorough discussion of how to implement things like FirstClassFunctions and FirstClassContinuations in an interpreter when the language you are writing the interpreter in does not support those features.
          </p>
          <footer>
            highlight
            
             @ loc 1354
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            Smalltalk’s designers did such a good job because they conceived of Smalltalk as a complete self-contained system. Whatever rules they came up with, they knew would apply everywhere, and they knew that no other rules would be relevant. Smalltalk is Everything.
          </p>
          <footer>
            highlight
            
             @ loc 1359
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            Scheme 48 had very little technical overlap w/T3 and Orbit — no native code compiler, no object system, no CPS IR. Its innovations were its module system, the language in which its VM was defined (“pre-scheme”), and its stack-management technology.
          </p>
          <footer>
            highlight
            
             @ loc 1360
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            Kelsey wrote a paper on this and its advantages. The module system was somewhat like SML’s, but allowed modular macros and had another fairly cool feature: when you defined a module, clauses let you specify which files held the module’s source. But *other* clauses let you specify which “reader” procedure to use to translate the character stream in the files to the s-expression tree handed to the compiler. So you could handle files with different concrete syntax — R5RS syntax, scsh syntax, S48 syntax, PLT Scheme syntax, guile syntax, perhaps an infix syntax
          </p>
          <footer>
            highlight
            
             @ loc 1363
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            when skeptics talk about subjects outside their domain of expertise, I’m struck by how irrelevant their comments are, and how ugly, shrill and trivial.
          </p>
          <footer>
            highlight
            
             @ loc 1364
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            Guy Steele’s “FOO” language, as found on the ll1.mit.edu mailing list (very small demo implementation of call with continuations)
          </p>
          <footer>
            highlight
            
             @ loc 1367
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            Pre-scheme was quite interesting. Kelsey published a paper on it, as well, I believe. It was Scheme in the sense that you could load it into a Scheme system and run the code. But it was restrictive — it required you to write in a fashion that allowed complete Hindley-Milner static type inference, and all higher-order procedures were beta-substituted away at compile time, meaning you could *straightforwardly* translate a prescheme program into “natural” C code with C-level effiency.
          </p>
          <footer>
            highlight
            
             @ loc 1368
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            Rails does not eat SeasideFramework alive, quite the contrary. Both are excellent frameworks, rails takes the traditional web architecture, makes it slick and integrated as hell, a joy to use in comparison to configuration heavy Java and .Net framworks, it is however, still the traditional request/response/stateless/html template/database web architecture. Seaside however, is an entirely different beast. First of all, it only deals with the web side of the framework, persistence is entirely up to you, object databases are most common, because they pretty much rule the roost in the Smalltalk world. Keep in mind, you don’t even need a database at all to build a Seaside application, because the Smalltalk image itself “is” a non transactional object database, so you prototype the entire application on live objects. Seaside has no html templates, it’s a control based framework where pages are, and are composed of live controls. Smalltalk’s syntax is fully capable of expressing html directly, thus no templates, you write your html in Smalltalk, allowing you the full expressive power of the language without having to weave it into html. There are no request response state issues, the entire request response cycle is hidden with the magic of continuations, your objects, pages, controls, all are written in standard OO style, as if you were writing a desktop application rather than a web application. Pages, which are just controls, can call and answer to each other and pass real objects back and forth between them, making Seaside far more capable of writing extremely complex applications than Rails with much less effort. The simple example is a multi step check out process, a shopping cart for example, Seaside allows then entire process to be written as a single routine, rather than spread out across multiple pages passing state back and forth. That’s the magic of WebTransactionsWithContinuations. Rails
          </p>
          <footer>
            highlight
            
             @ loc 1379
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            first-class macros can be a sensible notion.  See &lt;http://www.bawden.org/mtt/&gt;.
          </p>
          <footer>
            highlight
            
             @ loc 1381
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            Generalized LISP. D.C. Smith, Aug 1990. A coordinated set of high-level syntaxes for Common LISP. Contains Mlisp, Plisp and ordinary LISP, with an extensible framework for adding others. Written in Plisp. ftp://bric-a-brac.apple.com/dts/mac/lisp
          </p>
          <footer>
            highlight
            
             @ loc 1385
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            Kelsey’s diss: Compilation by Program Transformation. Ph.D.dissertation, Yale University, May 1989. Research Report 702, Department of Computer Science. A conference-length version of this dissertation appears in POPL 89.
          </p>
          <footer>
            highlight
            
             @ loc 1390
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            I posted a message on the Arc forum showing how to define a defmac macro that has the simplicity of syntax-rules with the added convenience of specifying keywords and captured names.
          </p>
          <footer>
            highlight
            
             @ loc 1399
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            funny–everyone knows that JavaScript’s event-loop concurrency model means that you don’t have the problems of threads with shared memory, locks, deadlocks, data races, etc that you have in languages like C or Java. Except that’s not right. JavaScript’s concurrency model is cooperative, which means that you don’t get descheduled if you don’t want to be, but everything else about shared memory concurrency is still there. As
          </p>
          <footer>
            highlight
            
             @ loc 1404
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            you may find two TRs interesting.  One describes &quot;shorthands&quot; (pronoun-like things) and the other describes &quot;histories&quot; (capture-like things): ftp://ftp.research.microsoft.com/pub/tr/tr-2000-03.ps ftp://ftp.research.microsoft.com/pub/tr/tr-2000-54.ps
          </p>
          <footer>
            highlight
            
             @ loc 1409
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            Except they are different. Id est traits try to remove the warts of mixins by 1) prohibiting internal state variables, 2) in the case of multiple mixins, providing a syntax to allow programmer’s to choose which method to mixin,
          </p>
          <footer>
            highlight
            
             @ loc 1441
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            Warhol wrote in his memoir “Popism,”
          </p>
          <footer>
            highlight
            
             @ loc 1446
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            Apparently, most people love watching the same basic thing, as long as the details are different.”
          </p>
          <footer>
            highlight
            
             @ loc 1448
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            A tale of restarts - comp.lang.dylan message by Chris Double (“This is a “I’m glad I used Dylan” story…”)
          </p>
          <footer>
            highlight
            
             @ loc 1452
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            “Sátántangó”
          </p>
          <footer>
            highlight
            
             @ loc 1452
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            Béla Tarr’s seven-hour
          </p>
          <footer>
            highlight
            
             @ loc 1452
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            money you spent for your ticket was well worth all this clamor,
          </p>
          <footer>
            highlight
            
             @ loc 1458
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            MOVIES may be the only art form whose core audience is widely believed to be actively hostile to ambition, difficulty or anything that seems to demand too much work on their part. In other words, there is, at every level of the culture — among studio executives, entertainment reporters, fans and quite a few critics — a lingering bias against the notion that movies should aspire to the highest levels of artistic accomplishment.
          </p>
          <footer>
            highlight
            
             @ loc 1466
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            “Who goes there?” Get it, ’cause that’s the title of the story that THE THING was based on. But
          </p>
          <footer>
            highlight
            
             @ loc 1532
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            we process text strings a lot. So I tried to work hard on text processing, namely the string class and regular expressions. Regular expressions are built into the language and are very tuned up for use. We also need to call into the operating system a lot.
          </p>
          <footer>
            highlight
            
             @ loc 1571
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            Common Lisp beat out Interlisp, and maybe for good reasons but it doesn't mean Interlisp had nothing to offer--some very good ideas got lost in the shuffle and I don't pretend that Common Lisp just obviously had a better way.
          </p>
          <footer>
            highlight
            
             @ loc 1641
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
             We owe it to the losers in these little skirmishes to make sure that, if nothing else, the good ideas are not lost along with the framework.
          </p>
          <footer>
            highlight
            
             @ loc 1644
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            Professor Michael Godfrey has done some studies on the Vim architecture and its development. You can find this at http://plg.uwaterloo.ca/~migod/.
          </p>
          <footer>
            highlight
            
             @ loc 1663
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            Although Design by Contract and assertions are very closely related, DbC is more than just slapping a few assertions into your code at strategic locations. It is about identifying the contract under which your code will execute and you expect all clients to adhere to. It is about clearly defining responsibilities between client software and supplier software.
          </p>
          <footer>
            highlight
            
             @ loc 1677
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            And that's my overall point.  It's not just about what's missing. It's about the lack of interest in those who have created Emacs in supporting those other things.
          </p>
          <footer>
            highlight
            
             @ loc 1681
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            in 2008 Ola Bini blogged about instance_eval and effectively recommended to stay away from it unless you know what you are doing.
          </p>
          <footer>
            highlight
            
             @ loc 1682
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            By identifying the contract, we are clearly identifying the responsibilities of each party in a collaboration. Knowing responsibilities is a big help when the time comes to get two (or more) modules to work together. Precondition violations mean that the client is in error. Postcondition violations mean that the supplier is incorrect.
          </p>
          <footer>
            highlight
            
             @ loc 1683
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            Require no more, promise no less.
          </p>
          <footer>
            highlight
            
             @ loc 1688
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            identifier needs to be a combination of a name and a lexical context.
          </p>
          <footer>
            highlight
            
             @ loc 1692
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            an identifier can be referenced from a place in the code where it is not visible by name.
          </p>
          <footer>
            highlight
            
             @ loc 1693
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            Although very similar in many ways, there are still some fundamental differences between DbC assertion checking and unit testing. Unit tests generally focus on a single module (class) and don’t exercise modules (classes) in concert together. In particular, unit test are a poor vehicle for checking preconditions.
          </p>
          <footer>
            highlight
            
             @ loc 1701
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            From a Design by Contract perspective, this is not testing preconditions. Preconditions define when it is legal to invoke a particular method. According to DbC, calling a method when its preconditions are not established results in undefined behavior. How can you test for undefined behavior?
          </p>
          <footer>
            highlight
            
             @ loc 1706
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            the routing defintion block it would not be able to call the routing helpers. Contrast this with the old API which is not only more concise but also much easier to compose by merely passing around data structures or wrapping the map proxy object. So what’s the point? Isn’t this just bad library design? I’m not sure it’s just that when even venerable frameworks like Rails are affected by such blunders.
          </p>
          <footer>
            highlight
            
             @ loc 1708
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            Without real metastructures.
          </p>
          <footer>
            highlight
            
             @ loc 1709
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            Without any mechanism to extend or enhance operators. Without any dynamic high quality run-time debugging support. Without a convenient syntax for literal arrays. Without a way to retroactively add methods to classes. Some of those are considered to be advantages: Java is certainly much less “reinvention of the world”. However, Smalltalk doesn’t have hierarchical namespaces. Some of us view this as a Smalltalk feature *smile* — TomStambaugh I agree wholeheartedly. I’ve been doing some pretty namespace-intensive stuff in VisualWorks 5i for the last month or so, and, frankly, I don’t see the big win. Namespaces (in Smalltalk) add lots of complexity for not much payoff. — AnthonyLander I would disagree about hierarchical naming through packages being a “bug” in Java as defined by Gosling by 1995 (the fair comparison with various Smalltalks should perhaps be around that timestamp, given that Smalltalk had a twenty year start). How else should class name clashes be avoided when composing stuff from multiple sources, including when downloading applets and loading servlet classes at runtime? Which reminds me, what about standards for loading new classes into virtual machines from separate suppliers? How’s Smalltalk doing at that these days? It worked well in 1995 for Java. Plus, what’s the comparative verdict on interfaces, threads and the monitor-based concurrency model Gosling may have copied from ModulaThree or Tony Hoare ( CarHoare )? — RichardDrake The only problem is that he chose the wrong Hoare paper! :) Java really should have used CommunicatingSequentialProcesses , a more recent Hoare paper that solved many of the problems associated with monitors. Happily, there are various Java implementations of CommunicatingSequentialProcesses . — RobertDiFalcoI wouldn’t deny that. But the comparison with Smalltalk computes to what? Good point. — RobertDiFalco On to interfaces, I think they are one of the most elegant solutions to the diamond multiple inheritance problem I have seen yet — much better than SmallTalk in this regard. I’m very happy with Java interfaces and how inheritance works. I know some would like true multiple inheritance, but I think this would open pandora’s box. Multiple interface inheritance slays the diamond problem perfectly. While effective, I think the C++ solution (virtual inheritance) is just plain ugly. — RobertDiFalco Are you aware of the EiffelLanguage approach? The compiler must work harder but it seems painless for programmers. It looks like MI of implementation is one of the things which Microsoft’s new system doesn’t support directly, so if they have their way we are stuck without it. Eg it’s one of the few differences between EiffelSharp ? and EiffelLanguage . — DaveHarris Dave, yeah. EiffelLanguage has an interesting approach. Of course, they also have CoVariance which is so great in so many ways. I would even be happy for return-type CoVariance in JavaLanguage or CeePlusPlus . This is one area where the no compile-time types of SmallTalk really shine — the whole covariance/contravariance issue is side-stepped. I also prefer EiffelLanguage ’s approach to genericity over CeePlusPlus templates. I think GenericJava is a good middle ground for JavaLanguage . — RobertDiFalco Robert, CeePlusPlus already has covariant return types (unless you’re using Visual C++ 6 or worse) and has had for years. It’s not vital in C++ (there are ways to get the same effect without it by combining non-virtual methods and virtual methods) but it would be useful in Java (where it can’t be simulated sensibly). — JamesDennett
          </p>
          <footer>
            highlight
            
             @ loc 1711
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            Without restartable exceptions.
          </p>
          <footer>
            highlight
            
             @ loc 1711
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            the macro special-form should only be allowed in places where its complete flow is visible at compile time and should never be allowed to materialize as a run-time object.
          </p>
          <footer>
            highlight
            
             @ loc 1716
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            DbC postconditions are general and answer the question of how a method responds under all possible legal conditions. Unit tests focus on how a method responds under certain, specific situations specified in the test.
          </p>
          <footer>
            highlight
            
             @ loc 1737
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            parallelism arises naturally in an eager, not a lazy, language—for
          </p>
          <footer>
            highlight
            
             @ loc 1743
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            Are you aware of delegation in SelfLanguage as an alternative to inheritance? Yes. The relationship between delegation and inheritance has been explored at great length, both in the literature and here.
          </p>
          <footer>
            highlight
            
             @ loc 1748
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            Because macroexpansion is performed before compilation, the compiler receives only core language expressions with known semantics (LAMBDA, DEFINE, SET, IF, …).
          </p>
          <footer>
            highlight
            
             @ loc 1752
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            I wish to argue that laziness is important, but not for pure functional programming, but rather only in conjunction with effects.
          </p>
          <footer>
            highlight
            
             @ loc 1756
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            What actually happens is that whenever we define a new class or module, its name is added as a constant that points to the actual class. Similarly, when we define a method at the top level it’s added as a private method to Object. That means that whenever we type in a name that looks like a constant (starts with a capital letter) without parenthesis, Ruby will search for that constant:
          </p>
          <footer>
            highlight
            
             @ loc 1773
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
             The role of memoization is to transform an ephemeral process into a persistent data structure by recording the successive values produced by the process so that they can be “replayed” as necessary to permit the stream to have multiple futures.  Thus, rather than being a matter of efficiency, memoization is a matter of functionality, providing a persistent interface to an underlying ephemeral process.
          </p>
          <footer>
            highlight
            
             @ loc 1773
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            I’m talking about fork(2), execve(2), pipe(2), socketpair(2), select(2), kill(2), sigaction(2), and so on and so forth. These are our friends. They want so badly just to help us.
          </p>
          <footer>
            highlight
            
             @ loc 1777
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            only the Perl people seem to regularly (and happily) apply common Unix idioms to a wide range of problem areas.
          </p>
          <footer>
            highlight
            
             @ loc 1787
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            Unix is not one of the “perlisms” Ruby should be trying to distance itself from. Perl got that part right.
          </p>
          <footer>
            highlight
            
             @ loc 1788
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
             True reuse operates at the level of abstractions, not at the level of the code that gives rise to them.
          </p>
          <footer>
            highlight
            
             @ loc 1794
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            Common Lisp's approach of modularizing the map from names to symbol objects instead of the map from symbol objects to bindings is wrong.  It comes from a 1974 historic context before lexical scoping.
          </p>
          <footer>
            highlight
            
             @ loc 1814
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            “absence of evidence is evidence of absence”
          </p>
          <footer>
            highlight
            
             @ loc 1816
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            Free Inquiry magazine,
          </p>
          <footer>
            highlight
            
             @ loc 1841
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
             In an ironic twist the emphasis on monads in Haskell means that programming in Haskell is rather like programming in an updated dialect of Algol with a richer type structure than the original, but the same overall structure.
          </p>
          <footer>
            highlight
            
             @ loc 1844
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            Instead of a blocking accept(2), Unicorn uses a blocking select(2) with an error pipe and a timeout so that it can bust out and do some other basic housekeeping, like reopening logs, processing signals, and maintaining a heartbeat with the master process.
          </p>
          <footer>
            highlight
            
             @ loc 1846
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            the ML module system can be deployed by you to impose the sorts of effect segregation imposed on you by default in Haskell.
          </p>
          <footer>
            highlight
            
             @ loc 1877
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            Agile is communication, trust and accountability. And that’s it. The rest is bullshit.
          </p>
          <footer>
            highlight
            
             @ loc 1887
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            realization that the B+-tree, a variation in which all keys reside in the leaves, and the internal nodes are purely redundant search structures, had substantial benefits compared to the original version; every practical BTree that I have ever studied has been a B+-tree. All of this work was collected and described by Doug Comer of Purdue University in the paper The ubiquitous B-tree in 1979.
          </p>
          <footer>
            highlight
            
             @ loc 1908
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            A ‘crutch’ in language design is a solution to a problem of accidental complexity.
          </p>
          <footer>
            highlight
            
             @ loc 1912
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            A very thorough and complete treatment of this Second Age of BTrees can be found in Jim Gray and Andreas Reuter’s encyclopedic Transaction Processing: Concepts and Techniques.
          </p>
          <footer>
            highlight
            
             @ loc 1921
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            The Kilim library for Java provides a fast zero-copy messaging system for Java which still enables mutable state. In Kilim, when one actor sends a message, it loses visibility of the object it sends, and it becomes the responsibility of the recipient. If both actors need a copy of the message, the sender can make a copy of an object before it’s sent to the recipient. Again, Erlang doesn’t provide zero-copy (except for binaries) so Kilim’s worst case is actually Erlang’s best case.
          </p>
          <footer>
            highlight
            
             @ loc 1922
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            Wiliam Goodell’s The American Slave Code in Theory and Practice
          </p>
          <footer>
            highlight
            
             @ loc 1934
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            An excellent description of the concepts in most Third Age BTrees can be found in Ohad Rodeh’s B-trees, Shadowing, and Clones.
          </p>
          <footer>
            highlight
            
             @ loc 1935
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            For the Scheme I wrote for Junglee's next-generation wrapper language, I allowed three abbreviations: (1) If a non-alphanumeric symbol appeared in the first or second element of a list to be evaled, then the list is in infix form.  So (x = 3 + 4) is (= x (+ 3 4)), and (- x * y) is (* (- x) y).  And (2), if a symbol is delimited by a &quot;(&quot;, then it moves inside the list.  So f(a b) is (f a b), while f (a b) is two s-exps.
          </p>
          <footer>
            highlight
            
             @ loc 1952
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            Query List Comprehensions (QLC).
          </p>
          <footer>
            highlight
            
             @ loc 1961
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            A related phenomenon commonly seen with software is bike-shedding, where interlocutors focus on surface details like naming and syntax… or (come to think of it) like lock combinations.
          </p>
          <footer>
            highlight
            
             @ loc 2006
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            On the other hand, software is easier than quantum physics, and the population of people able to make substantial suggestions about software systems is several orders of magnitude bigger than Feynman’s circle of colleagues.
          </p>
          <footer>
            highlight
            
             @ loc 2008
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            Manuel Serrano's little built-in, lightweight grammar    language, then people can use regexps to recognise regular languages    and CFGs to recognise more complex things.
          </p>
          <footer>
            highlight
            
             @ loc 2129
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
             http://www.research.microsoft.com/~toddpro/
          </p>
          <footer>
            highlight
            
             @ loc 2132
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            I wish every language used the same form for function call, hash fetches, and array indexing, the way arc does.
          </p>
          <footer>
            highlight
            
             @ loc 2144
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
             (Apply should probably be called &quot;call&quot;, if we're rebuilding Lisp from the ground up.)
          </p>
          <footer>
            highlight
            
             @ loc 2147
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
             John Howland has built a course around a set of programs parallel-coded in J and Scheme!  Try --   http://www.cs.trinity.edu/About/The_Courses/cs301/
          </p>
          <footer>
            highlight
            
             @ loc 2356
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            A Rant About Jargon : EvolutionBlog
          </p>
          <footer>
            highlight
            
             @ loc 2566
          </footer>
        </li>
        
      
        
        <li class="highlight">
          <p>
            translates the JavaScript abstract syntax tree to a high-level static single-assignment (SSA) representation called Hydrogen, and tries to optimize that Hydrogen graph. Then the Hydrogen is translated to the machine-specific Lithium low-level language, which facilitates register allocation and, finally, code generation.
          </p>
          <footer>
            highlight
            
             @ loc 3087
          </footer>
        </li>
        
      
    </ul>

    <footer>
      Generated by <a href="https://github.com/grassdog/klipbook">Klipbook 0.3.0</a> on <span>10 Sep 2012 at  2:27 pm</span>
    </footer>
  </body>
</html>
